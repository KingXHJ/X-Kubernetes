## Kubernetes Network Model
Kubernetes 网络模型设计的一个基础原则是：每个 Pod 都拥有一个独立的 IP 地址，并假定所有 Pod 都在一个可以直接连通的、扁平的网络空间中。所以不管它们是否运行在同一个 Node （宿主机）中，都要求它们可以直接通过对方的 IP 进行访问。设计这个原则的原因是，用户不需要额外考虑如何建立 Pod 之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。

实际上，在 Kubernetes 世界里，IP 是以 Pod 为单位进行分配的 。一个 Pod 内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的 IP 址、网络设备、配置等都是共享的）。按照这个网络原则抽象出来的为每个 Pod 都设置一个 IP 地址的模型也被称作 IP-per-Pod 模型。

由于 Kubemetes 的网络模型假设 Pod 之间访问时使用的是对方 Pod 的实际地址，所以一个 Pod 内部的应用程序看到的自己的 IP 地址和端口与集群内其他 Pod 看到的一样 。它们都是 Pod 实际分配的 IP 地址。将 IP 地址和端口在 Pod 内部和外部都保持一致，也就不需要使用 NAT 进行地址转换了。Kubemetes 的网络之所以这么设计，主要原因就是可以兼容过去的应用。当然，我们使用 Linux 命令 ip addr show 也能看到这些地址，与程序看到的没有什么区别。所以这种 IP-per-Pod 的方案很好地利用了现有的各种域名解析和发现机制。

为每个 Pod 都设置一个 IP 地址的模型还有另外一层含义，那就是同一个 Pod 内的不同容器会共享同一个网络命名空间，也就是同一个 Linux 网络协议栈。这就意味着同一个 Pod 内的容器可以通过 localhost 连接对方的端口。这种关系和同一个 VM 内的进程之间的关系是一样的，看起来 Pod 内容器之间的隔离性减小了，而且 Pod 内不同容器之间的端口是共享的，就没有所谓的私有端口的概念了。如果你的应用必须使用一些特定的端口范围，那么你也可以为这些应用单独创建一些 Pod 反之，对那些没有特殊需要的应用，由于 Pod 内的容器是共享部分资源的，所以可以通过共享资源相互通信，这显然更加容易和高效。针对这些应用，虽然损失了可接受范围内的部分隔离性，却也是值得的

IP-per-Pod 模式和 Docker 原生的通过动态端口映射方式实现的多节点访问模式有什么区别呢？主要区别是后者的动态端口映射会引入端口管理的复杂性，而且访问者看到的 IP 地址和端口与服务提供者实际绑定的不同（因为 NAT 的缘故，它们都被映射成新的地址或端口），这也会引起应用配置的复杂化。同时，标准的 DNS 等名字解析服务也不适用了，甚至服务注册和发现机制都将迎来挑战，因为在端口映射情况下，服务自身艰难知道自己对外暴露的真实服务 IP 和端口，外部应用也无法通过服务所在容器的私有 IP 地址和端口来访问服务

总的来说，IP-per-Pod 模型是一个简单的兼容性较好的模型。从该模型的网络的端口分配、域名解析、服务发现、负载均衡、应用配置和迁移等角度来看，Pod 都能够被看作一台独立的虚拟机或物理机

按照这个网络抽象原则，Kubernetes 对网络有什么前提和要求呢？
1. 所有 Pod 都可以在不用 NAT 的方式下同别 Pod 通信
1. 在所有节点上运行的代理程序（例如 kubelet 或操作系统守护进程）都可以在不用 NAT 的方式下同所有 Pod 通信，反之亦然
1. 以hostnetwork 模式运行的 Pod 都可以在不用 NAT 的方式下同别的 Pod 通信。

这些基本要求意味着并不是两台机器都运行 Docker，Kubernetes 就可以工作了。具体的集群网络实现必须满足上述要求，原生的 Docker 网络目前还不能很好地满足这些要求。

实际上，这些对网络模型的要求并没有降低整个网络系统的复杂度。如果你的程序原来在 VM 运行，那些 VM 拥有独立 IP, 并且它们之间可以直接透明地通信，那么 Kubernetes 的网络模型就和 VM 使用的网络模型一样。所以，使用这种模型可以很容易地将已有的应用程序从 VM 或者物理机迁移到容器上。

